{"version":3,"file":"HttpLlmApplicationComposer.mjs","sources":["../../src/composers/HttpLlmApplicationComposer.ts"],"sourcesContent":["import { OpenApi } from \"../OpenApi\";\nimport { IChatGptSchema } from \"../structures/IChatGptSchema\";\nimport { IHttpLlmApplication } from \"../structures/IHttpLlmApplication\";\nimport { IHttpLlmFunction } from \"../structures/IHttpLlmFunction\";\nimport { IHttpMigrateApplication } from \"../structures/IHttpMigrateApplication\";\nimport { IHttpMigrateRoute } from \"../structures/IHttpMigrateRoute\";\nimport { ILlmFunction } from \"../structures/ILlmFunction\";\nimport { ILlmSchema } from \"../structures/ILlmSchema\";\nimport { LlmSchemaComposer } from \"./LlmSchemaComposer\";\n\nexport namespace HttpLlmComposer {\n  export const application = <Model extends ILlmSchema.Model>(props: {\n    model: Model;\n    migrate: IHttpMigrateApplication;\n    options: IHttpLlmApplication.IOptions<Model>;\n  }): IHttpLlmApplication<Model> => {\n    // COMPOSE FUNCTIONS\n    const errors: IHttpLlmApplication.IError[] = props.migrate.errors.map(\n      (e) => ({\n        method: e.method,\n        path: e.path,\n        messages: e.messages,\n        operation: () => e.operation(),\n        route: () => undefined,\n      }),\n    );\n    const functions: IHttpLlmFunction<Model>[] = props.migrate.routes\n      .map((route, i) => {\n        if (route.method === \"head\") {\n          errors.push({\n            method: route.method,\n            path: route.path,\n            messages: [\"HEAD method is not supported in the LLM application.\"],\n            operation: () => route.operation(),\n            route: () => route as any as IHttpMigrateRoute,\n          });\n          return null;\n        } else if (\n          route.body?.type === \"multipart/form-data\" ||\n          route.success?.type === \"multipart/form-data\"\n        ) {\n          errors.push({\n            method: route.method,\n            path: route.path,\n            messages: [\n              `The \"multipart/form-data\" content type is not supported in the LLM application.`,\n            ],\n            operation: () => route.operation(),\n            route: () => route as any as IHttpMigrateRoute,\n          });\n          return null;\n        }\n        const localErrors: string[] = [];\n        const func: IHttpLlmFunction<Model> | null = composeFunction<Model>({\n          model: props.model,\n          options: props.options,\n          components: props.migrate.document().components,\n          route: route,\n          errors: localErrors,\n          index: i,\n        });\n        if (func === null)\n          errors.push({\n            method: route.method,\n            path: route.path,\n            messages: localErrors,\n            operation: () => route.operation(),\n            route: () => route as any as IHttpMigrateRoute,\n          });\n        return func;\n      })\n      .filter((v): v is IHttpLlmFunction<Model> => v !== null);\n    return {\n      model: props.model,\n      options: props.options,\n      functions,\n      errors,\n    };\n  };\n\n  const composeFunction = <Model extends ILlmSchema.Model>(props: {\n    model: Model;\n    components: OpenApi.IComponents;\n    route: IHttpMigrateRoute;\n    options: IHttpLlmApplication.IOptions<Model>;\n    errors: string[];\n    index: number;\n  }): IHttpLlmFunction<Model> | null => {\n    const $defs: Record<string, IChatGptSchema> = {};\n    const cast = (\n      s: OpenApi.IJsonSchema,\n      accessor: string,\n    ): ILlmSchema.ModelSchema[Model] | null => {\n      const result = LlmSchemaComposer.schema(props.model)({\n        config: props.options as any,\n        schema: s,\n        components: props.components,\n        $defs,\n        accessor,\n        refAccessor: `$input.components.schemas`,\n      });\n      if (result.success === false) {\n        props.errors.push(\n          ...result.error.reasons.map((r) => `${r.accessor}: ${r.message}`),\n        );\n        return null;\n      }\n      return result.value as ILlmSchema.ModelSchema[Model];\n    };\n\n    const endpoint: string = `$input.paths[${JSON.stringify(props.route.path)}][${JSON.stringify(props.route.method)}]`;\n    const output: ILlmSchema.ModelSchema[Model] | null | undefined = props.route\n      .success\n      ? cast(\n          props.route.success.schema,\n          `${endpoint}.responses[${JSON.stringify(props.route.success.status)}][${JSON.stringify(props.route.success.type)}].schema`,\n        )\n      : undefined;\n    const properties: Array<\n      readonly [string, ILlmSchema.ModelSchema[Model] | null]\n    > = [\n      ...props.route.parameters.map(\n        (s) =>\n          [\n            s.key,\n            cast(\n              {\n                ...s.schema,\n                title: s.parameter().title ?? s.schema.title,\n                description: s.parameter().description ?? s.schema.description,\n              },\n              `${endpoint}.parameters[${JSON.stringify(s.key)}].schema`,\n            ),\n          ] as const,\n      ),\n      ...(props.route.query\n        ? [\n            [\n              props.route.query.key,\n              cast(\n                {\n                  ...props.route.query.schema,\n                  title:\n                    props.route.query.title() ?? props.route.query.schema.title,\n                  description:\n                    props.route.query.description() ??\n                    props.route.query.schema.description,\n                },\n                `${endpoint}.parameters[${JSON.stringify(props.route.query.key)}].schema`,\n              ),\n            ] as const,\n          ]\n        : []),\n      ...(props.route.body\n        ? [\n            [\n              props.route.body.key,\n              cast(\n                {\n                  ...props.route.body.schema,\n                  description:\n                    props.route.body.description() ??\n                    props.route.body.schema.description,\n                },\n                `${endpoint}.requestBody.content[${JSON.stringify(props.route.body.type)}].schema`,\n              ),\n            ] as const,\n          ]\n        : []),\n    ];\n    if (output === null || properties.some(([_k, v]) => v === null))\n      return null;\n\n    // COMPOSE PARAMETERS\n    const parameters: ILlmSchema.ModelParameters[Model] = {\n      type: \"object\",\n      properties: Object.fromEntries(\n        properties as [string, ILlmSchema.ModelSchema[Model]][],\n      ),\n      additionalProperties: false,\n      required: properties.map(([k]) => k),\n    } as any as ILlmSchema.ModelParameters[Model];\n    if (Object.keys($defs).length)\n      (parameters as any as IChatGptSchema.IParameters).$defs = $defs;\n    const operation: OpenApi.IOperation = props.route.operation();\n\n    // FINALIZATION\n    return {\n      method: props.route.method as \"get\",\n      path: props.route.path,\n      name: props.route.accessor.join(\"_\"),\n      strict: true,\n      parameters,\n      separated: props.options.separate\n        ? (LlmSchemaComposer.separateParameters(props.model)({\n            predicate: props.options.separate as any,\n            parameters:\n              parameters satisfies ILlmSchema.ModelParameters[Model] as any,\n          }) as ILlmFunction.ISeparated<Model>)\n        : undefined,\n      output: output as any,\n      description: (() => {\n        if (!operation.summary?.length || !operation.description?.length)\n          return operation.summary || operation.description;\n        const summary: string = operation.summary.endsWith(\".\")\n          ? operation.summary.slice(0, -1)\n          : operation.summary;\n        return operation.description.startsWith(summary)\n          ? operation.description\n          : summary + \".\\n\\n\" + operation.description;\n      })(),\n      deprecated: operation.deprecated,\n      tags: operation.tags,\n      route: () => props.route as any,\n      operation: () => props.route.operation(),\n    };\n  };\n}\n"],"names":["HttpLlmComposer","application","props","errors","migrate","map","e","method","path","messages","operation","route","undefined","functions","routes","i","push","body","type","success","localErrors","func","composeFunction","model","options","components","document","index","filter","v","$defs","cast","s","accessor","result","LlmSchemaComposer","schema","config","refAccessor","error","reasons","r","message","value","endpoint","JSON","stringify","output","status","properties","parameters","key","title","parameter","description","query","some","_k","Object","fromEntries","additionalProperties","required","k","keys","length","name","join","strict","separated","separate","separateParameters","predicate","summary","endsWith","slice","startsWith","deprecated","tags"],"mappings":"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"}